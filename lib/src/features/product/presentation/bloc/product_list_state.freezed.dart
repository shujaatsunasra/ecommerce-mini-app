// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'product_list_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ProductListState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(ProductList productList) loadingMore,
    required TResult Function(ProductList productList, bool isOffline) success,
    required TResult Function(
            String message, ProductList? productList, bool isOffline)
        error,
    required TResult Function(String message, bool isOffline) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(ProductList productList)? loadingMore,
    TResult? Function(ProductList productList, bool isOffline)? success,
    TResult? Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult? Function(String message, bool isOffline)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(ProductList productList)? loadingMore,
    TResult Function(ProductList productList, bool isOffline)? success,
    TResult Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult Function(String message, bool isOffline)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductListInitial value) initial,
    required TResult Function(ProductListLoading value) loading,
    required TResult Function(ProductListLoadingMore value) loadingMore,
    required TResult Function(ProductListSuccess value) success,
    required TResult Function(ProductListError value) error,
    required TResult Function(ProductListEmpty value) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductListInitial value)? initial,
    TResult? Function(ProductListLoading value)? loading,
    TResult? Function(ProductListLoadingMore value)? loadingMore,
    TResult? Function(ProductListSuccess value)? success,
    TResult? Function(ProductListError value)? error,
    TResult? Function(ProductListEmpty value)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductListInitial value)? initial,
    TResult Function(ProductListLoading value)? loading,
    TResult Function(ProductListLoadingMore value)? loadingMore,
    TResult Function(ProductListSuccess value)? success,
    TResult Function(ProductListError value)? error,
    TResult Function(ProductListEmpty value)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProductListStateCopyWith<$Res> {
  factory $ProductListStateCopyWith(
          ProductListState value, $Res Function(ProductListState) then) =
      _$ProductListStateCopyWithImpl<$Res, ProductListState>;
}

/// @nodoc
class _$ProductListStateCopyWithImpl<$Res, $Val extends ProductListState>
    implements $ProductListStateCopyWith<$Res> {
  _$ProductListStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ProductListInitialImplCopyWith<$Res> {
  factory _$$ProductListInitialImplCopyWith(_$ProductListInitialImpl value,
          $Res Function(_$ProductListInitialImpl) then) =
      __$$ProductListInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProductListInitialImplCopyWithImpl<$Res>
    extends _$ProductListStateCopyWithImpl<$Res, _$ProductListInitialImpl>
    implements _$$ProductListInitialImplCopyWith<$Res> {
  __$$ProductListInitialImplCopyWithImpl(_$ProductListInitialImpl _value,
      $Res Function(_$ProductListInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProductListInitialImpl implements ProductListInitial {
  const _$ProductListInitialImpl();

  @override
  String toString() {
    return 'ProductListState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProductListInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(ProductList productList) loadingMore,
    required TResult Function(ProductList productList, bool isOffline) success,
    required TResult Function(
            String message, ProductList? productList, bool isOffline)
        error,
    required TResult Function(String message, bool isOffline) empty,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(ProductList productList)? loadingMore,
    TResult? Function(ProductList productList, bool isOffline)? success,
    TResult? Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult? Function(String message, bool isOffline)? empty,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(ProductList productList)? loadingMore,
    TResult Function(ProductList productList, bool isOffline)? success,
    TResult Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult Function(String message, bool isOffline)? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductListInitial value) initial,
    required TResult Function(ProductListLoading value) loading,
    required TResult Function(ProductListLoadingMore value) loadingMore,
    required TResult Function(ProductListSuccess value) success,
    required TResult Function(ProductListError value) error,
    required TResult Function(ProductListEmpty value) empty,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductListInitial value)? initial,
    TResult? Function(ProductListLoading value)? loading,
    TResult? Function(ProductListLoadingMore value)? loadingMore,
    TResult? Function(ProductListSuccess value)? success,
    TResult? Function(ProductListError value)? error,
    TResult? Function(ProductListEmpty value)? empty,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductListInitial value)? initial,
    TResult Function(ProductListLoading value)? loading,
    TResult Function(ProductListLoadingMore value)? loadingMore,
    TResult Function(ProductListSuccess value)? success,
    TResult Function(ProductListError value)? error,
    TResult Function(ProductListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ProductListInitial implements ProductListState {
  const factory ProductListInitial() = _$ProductListInitialImpl;
}

/// @nodoc
abstract class _$$ProductListLoadingImplCopyWith<$Res> {
  factory _$$ProductListLoadingImplCopyWith(_$ProductListLoadingImpl value,
          $Res Function(_$ProductListLoadingImpl) then) =
      __$$ProductListLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProductListLoadingImplCopyWithImpl<$Res>
    extends _$ProductListStateCopyWithImpl<$Res, _$ProductListLoadingImpl>
    implements _$$ProductListLoadingImplCopyWith<$Res> {
  __$$ProductListLoadingImplCopyWithImpl(_$ProductListLoadingImpl _value,
      $Res Function(_$ProductListLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProductListLoadingImpl implements ProductListLoading {
  const _$ProductListLoadingImpl();

  @override
  String toString() {
    return 'ProductListState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProductListLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(ProductList productList) loadingMore,
    required TResult Function(ProductList productList, bool isOffline) success,
    required TResult Function(
            String message, ProductList? productList, bool isOffline)
        error,
    required TResult Function(String message, bool isOffline) empty,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(ProductList productList)? loadingMore,
    TResult? Function(ProductList productList, bool isOffline)? success,
    TResult? Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult? Function(String message, bool isOffline)? empty,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(ProductList productList)? loadingMore,
    TResult Function(ProductList productList, bool isOffline)? success,
    TResult Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult Function(String message, bool isOffline)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductListInitial value) initial,
    required TResult Function(ProductListLoading value) loading,
    required TResult Function(ProductListLoadingMore value) loadingMore,
    required TResult Function(ProductListSuccess value) success,
    required TResult Function(ProductListError value) error,
    required TResult Function(ProductListEmpty value) empty,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductListInitial value)? initial,
    TResult? Function(ProductListLoading value)? loading,
    TResult? Function(ProductListLoadingMore value)? loadingMore,
    TResult? Function(ProductListSuccess value)? success,
    TResult? Function(ProductListError value)? error,
    TResult? Function(ProductListEmpty value)? empty,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductListInitial value)? initial,
    TResult Function(ProductListLoading value)? loading,
    TResult Function(ProductListLoadingMore value)? loadingMore,
    TResult Function(ProductListSuccess value)? success,
    TResult Function(ProductListError value)? error,
    TResult Function(ProductListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ProductListLoading implements ProductListState {
  const factory ProductListLoading() = _$ProductListLoadingImpl;
}

/// @nodoc
abstract class _$$ProductListLoadingMoreImplCopyWith<$Res> {
  factory _$$ProductListLoadingMoreImplCopyWith(
          _$ProductListLoadingMoreImpl value,
          $Res Function(_$ProductListLoadingMoreImpl) then) =
      __$$ProductListLoadingMoreImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ProductList productList});

  $ProductListCopyWith<$Res> get productList;
}

/// @nodoc
class __$$ProductListLoadingMoreImplCopyWithImpl<$Res>
    extends _$ProductListStateCopyWithImpl<$Res, _$ProductListLoadingMoreImpl>
    implements _$$ProductListLoadingMoreImplCopyWith<$Res> {
  __$$ProductListLoadingMoreImplCopyWithImpl(
      _$ProductListLoadingMoreImpl _value,
      $Res Function(_$ProductListLoadingMoreImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productList = null,
  }) {
    return _then(_$ProductListLoadingMoreImpl(
      productList: null == productList
          ? _value.productList
          : productList // ignore: cast_nullable_to_non_nullable
              as ProductList,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ProductListCopyWith<$Res> get productList {
    return $ProductListCopyWith<$Res>(_value.productList, (value) {
      return _then(_value.copyWith(productList: value));
    });
  }
}

/// @nodoc

class _$ProductListLoadingMoreImpl implements ProductListLoadingMore {
  const _$ProductListLoadingMoreImpl({required this.productList});

  @override
  final ProductList productList;

  @override
  String toString() {
    return 'ProductListState.loadingMore(productList: $productList)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductListLoadingMoreImpl &&
            (identical(other.productList, productList) ||
                other.productList == productList));
  }

  @override
  int get hashCode => Object.hash(runtimeType, productList);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductListLoadingMoreImplCopyWith<_$ProductListLoadingMoreImpl>
      get copyWith => __$$ProductListLoadingMoreImplCopyWithImpl<
          _$ProductListLoadingMoreImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(ProductList productList) loadingMore,
    required TResult Function(ProductList productList, bool isOffline) success,
    required TResult Function(
            String message, ProductList? productList, bool isOffline)
        error,
    required TResult Function(String message, bool isOffline) empty,
  }) {
    return loadingMore(productList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(ProductList productList)? loadingMore,
    TResult? Function(ProductList productList, bool isOffline)? success,
    TResult? Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult? Function(String message, bool isOffline)? empty,
  }) {
    return loadingMore?.call(productList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(ProductList productList)? loadingMore,
    TResult Function(ProductList productList, bool isOffline)? success,
    TResult Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult Function(String message, bool isOffline)? empty,
    required TResult orElse(),
  }) {
    if (loadingMore != null) {
      return loadingMore(productList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductListInitial value) initial,
    required TResult Function(ProductListLoading value) loading,
    required TResult Function(ProductListLoadingMore value) loadingMore,
    required TResult Function(ProductListSuccess value) success,
    required TResult Function(ProductListError value) error,
    required TResult Function(ProductListEmpty value) empty,
  }) {
    return loadingMore(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductListInitial value)? initial,
    TResult? Function(ProductListLoading value)? loading,
    TResult? Function(ProductListLoadingMore value)? loadingMore,
    TResult? Function(ProductListSuccess value)? success,
    TResult? Function(ProductListError value)? error,
    TResult? Function(ProductListEmpty value)? empty,
  }) {
    return loadingMore?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductListInitial value)? initial,
    TResult Function(ProductListLoading value)? loading,
    TResult Function(ProductListLoadingMore value)? loadingMore,
    TResult Function(ProductListSuccess value)? success,
    TResult Function(ProductListError value)? error,
    TResult Function(ProductListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (loadingMore != null) {
      return loadingMore(this);
    }
    return orElse();
  }
}

abstract class ProductListLoadingMore implements ProductListState {
  const factory ProductListLoadingMore(
      {required final ProductList productList}) = _$ProductListLoadingMoreImpl;

  ProductList get productList;
  @JsonKey(ignore: true)
  _$$ProductListLoadingMoreImplCopyWith<_$ProductListLoadingMoreImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductListSuccessImplCopyWith<$Res> {
  factory _$$ProductListSuccessImplCopyWith(_$ProductListSuccessImpl value,
          $Res Function(_$ProductListSuccessImpl) then) =
      __$$ProductListSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ProductList productList, bool isOffline});

  $ProductListCopyWith<$Res> get productList;
}

/// @nodoc
class __$$ProductListSuccessImplCopyWithImpl<$Res>
    extends _$ProductListStateCopyWithImpl<$Res, _$ProductListSuccessImpl>
    implements _$$ProductListSuccessImplCopyWith<$Res> {
  __$$ProductListSuccessImplCopyWithImpl(_$ProductListSuccessImpl _value,
      $Res Function(_$ProductListSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productList = null,
    Object? isOffline = null,
  }) {
    return _then(_$ProductListSuccessImpl(
      productList: null == productList
          ? _value.productList
          : productList // ignore: cast_nullable_to_non_nullable
              as ProductList,
      isOffline: null == isOffline
          ? _value.isOffline
          : isOffline // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ProductListCopyWith<$Res> get productList {
    return $ProductListCopyWith<$Res>(_value.productList, (value) {
      return _then(_value.copyWith(productList: value));
    });
  }
}

/// @nodoc

class _$ProductListSuccessImpl implements ProductListSuccess {
  const _$ProductListSuccessImpl(
      {required this.productList, this.isOffline = false});

  @override
  final ProductList productList;
  @override
  @JsonKey()
  final bool isOffline;

  @override
  String toString() {
    return 'ProductListState.success(productList: $productList, isOffline: $isOffline)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductListSuccessImpl &&
            (identical(other.productList, productList) ||
                other.productList == productList) &&
            (identical(other.isOffline, isOffline) ||
                other.isOffline == isOffline));
  }

  @override
  int get hashCode => Object.hash(runtimeType, productList, isOffline);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductListSuccessImplCopyWith<_$ProductListSuccessImpl> get copyWith =>
      __$$ProductListSuccessImplCopyWithImpl<_$ProductListSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(ProductList productList) loadingMore,
    required TResult Function(ProductList productList, bool isOffline) success,
    required TResult Function(
            String message, ProductList? productList, bool isOffline)
        error,
    required TResult Function(String message, bool isOffline) empty,
  }) {
    return success(productList, isOffline);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(ProductList productList)? loadingMore,
    TResult? Function(ProductList productList, bool isOffline)? success,
    TResult? Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult? Function(String message, bool isOffline)? empty,
  }) {
    return success?.call(productList, isOffline);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(ProductList productList)? loadingMore,
    TResult Function(ProductList productList, bool isOffline)? success,
    TResult Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult Function(String message, bool isOffline)? empty,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(productList, isOffline);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductListInitial value) initial,
    required TResult Function(ProductListLoading value) loading,
    required TResult Function(ProductListLoadingMore value) loadingMore,
    required TResult Function(ProductListSuccess value) success,
    required TResult Function(ProductListError value) error,
    required TResult Function(ProductListEmpty value) empty,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductListInitial value)? initial,
    TResult? Function(ProductListLoading value)? loading,
    TResult? Function(ProductListLoadingMore value)? loadingMore,
    TResult? Function(ProductListSuccess value)? success,
    TResult? Function(ProductListError value)? error,
    TResult? Function(ProductListEmpty value)? empty,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductListInitial value)? initial,
    TResult Function(ProductListLoading value)? loading,
    TResult Function(ProductListLoadingMore value)? loadingMore,
    TResult Function(ProductListSuccess value)? success,
    TResult Function(ProductListError value)? error,
    TResult Function(ProductListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class ProductListSuccess implements ProductListState {
  const factory ProductListSuccess(
      {required final ProductList productList,
      final bool isOffline}) = _$ProductListSuccessImpl;

  ProductList get productList;
  bool get isOffline;
  @JsonKey(ignore: true)
  _$$ProductListSuccessImplCopyWith<_$ProductListSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductListErrorImplCopyWith<$Res> {
  factory _$$ProductListErrorImplCopyWith(_$ProductListErrorImpl value,
          $Res Function(_$ProductListErrorImpl) then) =
      __$$ProductListErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message, ProductList? productList, bool isOffline});

  $ProductListCopyWith<$Res>? get productList;
}

/// @nodoc
class __$$ProductListErrorImplCopyWithImpl<$Res>
    extends _$ProductListStateCopyWithImpl<$Res, _$ProductListErrorImpl>
    implements _$$ProductListErrorImplCopyWith<$Res> {
  __$$ProductListErrorImplCopyWithImpl(_$ProductListErrorImpl _value,
      $Res Function(_$ProductListErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? productList = freezed,
    Object? isOffline = null,
  }) {
    return _then(_$ProductListErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      productList: freezed == productList
          ? _value.productList
          : productList // ignore: cast_nullable_to_non_nullable
              as ProductList?,
      isOffline: null == isOffline
          ? _value.isOffline
          : isOffline // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ProductListCopyWith<$Res>? get productList {
    if (_value.productList == null) {
      return null;
    }

    return $ProductListCopyWith<$Res>(_value.productList!, (value) {
      return _then(_value.copyWith(productList: value));
    });
  }
}

/// @nodoc

class _$ProductListErrorImpl implements ProductListError {
  const _$ProductListErrorImpl(
      {required this.message, this.productList, this.isOffline = false});

  @override
  final String message;
  @override
  final ProductList? productList;
  @override
  @JsonKey()
  final bool isOffline;

  @override
  String toString() {
    return 'ProductListState.error(message: $message, productList: $productList, isOffline: $isOffline)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductListErrorImpl &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.productList, productList) ||
                other.productList == productList) &&
            (identical(other.isOffline, isOffline) ||
                other.isOffline == isOffline));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message, productList, isOffline);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductListErrorImplCopyWith<_$ProductListErrorImpl> get copyWith =>
      __$$ProductListErrorImplCopyWithImpl<_$ProductListErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(ProductList productList) loadingMore,
    required TResult Function(ProductList productList, bool isOffline) success,
    required TResult Function(
            String message, ProductList? productList, bool isOffline)
        error,
    required TResult Function(String message, bool isOffline) empty,
  }) {
    return error(message, productList, isOffline);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(ProductList productList)? loadingMore,
    TResult? Function(ProductList productList, bool isOffline)? success,
    TResult? Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult? Function(String message, bool isOffline)? empty,
  }) {
    return error?.call(message, productList, isOffline);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(ProductList productList)? loadingMore,
    TResult Function(ProductList productList, bool isOffline)? success,
    TResult Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult Function(String message, bool isOffline)? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message, productList, isOffline);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductListInitial value) initial,
    required TResult Function(ProductListLoading value) loading,
    required TResult Function(ProductListLoadingMore value) loadingMore,
    required TResult Function(ProductListSuccess value) success,
    required TResult Function(ProductListError value) error,
    required TResult Function(ProductListEmpty value) empty,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductListInitial value)? initial,
    TResult? Function(ProductListLoading value)? loading,
    TResult? Function(ProductListLoadingMore value)? loadingMore,
    TResult? Function(ProductListSuccess value)? success,
    TResult? Function(ProductListError value)? error,
    TResult? Function(ProductListEmpty value)? empty,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductListInitial value)? initial,
    TResult Function(ProductListLoading value)? loading,
    TResult Function(ProductListLoadingMore value)? loadingMore,
    TResult Function(ProductListSuccess value)? success,
    TResult Function(ProductListError value)? error,
    TResult Function(ProductListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ProductListError implements ProductListState {
  const factory ProductListError(
      {required final String message,
      final ProductList? productList,
      final bool isOffline}) = _$ProductListErrorImpl;

  String get message;
  ProductList? get productList;
  bool get isOffline;
  @JsonKey(ignore: true)
  _$$ProductListErrorImplCopyWith<_$ProductListErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductListEmptyImplCopyWith<$Res> {
  factory _$$ProductListEmptyImplCopyWith(_$ProductListEmptyImpl value,
          $Res Function(_$ProductListEmptyImpl) then) =
      __$$ProductListEmptyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message, bool isOffline});
}

/// @nodoc
class __$$ProductListEmptyImplCopyWithImpl<$Res>
    extends _$ProductListStateCopyWithImpl<$Res, _$ProductListEmptyImpl>
    implements _$$ProductListEmptyImplCopyWith<$Res> {
  __$$ProductListEmptyImplCopyWithImpl(_$ProductListEmptyImpl _value,
      $Res Function(_$ProductListEmptyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? isOffline = null,
  }) {
    return _then(_$ProductListEmptyImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      isOffline: null == isOffline
          ? _value.isOffline
          : isOffline // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ProductListEmptyImpl implements ProductListEmpty {
  const _$ProductListEmptyImpl({required this.message, this.isOffline = false});

  @override
  final String message;
  @override
  @JsonKey()
  final bool isOffline;

  @override
  String toString() {
    return 'ProductListState.empty(message: $message, isOffline: $isOffline)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductListEmptyImpl &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.isOffline, isOffline) ||
                other.isOffline == isOffline));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message, isOffline);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductListEmptyImplCopyWith<_$ProductListEmptyImpl> get copyWith =>
      __$$ProductListEmptyImplCopyWithImpl<_$ProductListEmptyImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(ProductList productList) loadingMore,
    required TResult Function(ProductList productList, bool isOffline) success,
    required TResult Function(
            String message, ProductList? productList, bool isOffline)
        error,
    required TResult Function(String message, bool isOffline) empty,
  }) {
    return empty(message, isOffline);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(ProductList productList)? loadingMore,
    TResult? Function(ProductList productList, bool isOffline)? success,
    TResult? Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult? Function(String message, bool isOffline)? empty,
  }) {
    return empty?.call(message, isOffline);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(ProductList productList)? loadingMore,
    TResult Function(ProductList productList, bool isOffline)? success,
    TResult Function(String message, ProductList? productList, bool isOffline)?
        error,
    TResult Function(String message, bool isOffline)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(message, isOffline);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProductListInitial value) initial,
    required TResult Function(ProductListLoading value) loading,
    required TResult Function(ProductListLoadingMore value) loadingMore,
    required TResult Function(ProductListSuccess value) success,
    required TResult Function(ProductListError value) error,
    required TResult Function(ProductListEmpty value) empty,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProductListInitial value)? initial,
    TResult? Function(ProductListLoading value)? loading,
    TResult? Function(ProductListLoadingMore value)? loadingMore,
    TResult? Function(ProductListSuccess value)? success,
    TResult? Function(ProductListError value)? error,
    TResult? Function(ProductListEmpty value)? empty,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProductListInitial value)? initial,
    TResult Function(ProductListLoading value)? loading,
    TResult Function(ProductListLoadingMore value)? loadingMore,
    TResult Function(ProductListSuccess value)? success,
    TResult Function(ProductListError value)? error,
    TResult Function(ProductListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class ProductListEmpty implements ProductListState {
  const factory ProductListEmpty(
      {required final String message,
      final bool isOffline}) = _$ProductListEmptyImpl;

  String get message;
  bool get isOffline;
  @JsonKey(ignore: true)
  _$$ProductListEmptyImplCopyWith<_$ProductListEmptyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
